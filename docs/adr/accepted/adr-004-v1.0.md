# ADR-004: FastMCP Lifecycle Management - Shutdown Hook Antipattern

**Status:** Accepted
**Date:** 2025-12-22
**Amends:** ADR-002 (Project Skills as Platform Engineering)
**Context:** During HGNC and UniProt server implementations, both initially attempted to use `@mcp.on_event("shutdown")` decorators for resource cleanup, resulting in runtime errors. This ADR documents the correct FastMCP lifecycle pattern and establishes it as a normative standard for all MCP server implementations.

**Reference:**
- [Model Context Protocol - Lifecycle](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle) - MCP Protocol specification
- [FastMCP Quickstart](https://gofastmcp.com/getting-started/quickstart) - Official FastMCP documentation
- Empirical findings: HGNC server (PR #3), UniProt server (branch `002-uniprot-us3-us4`)

---

## 1. Context and Problem Statement

### 1.1 The Problem

When implementing resource cleanup for async HTTP clients (httpx) in MCP servers, a natural assumption is to use lifecycle event handlers similar to FastAPI or other web frameworks:

```python
# ❌ ANTIPATTERN - This does not work in FastMCP
from fastmcp import FastMCP

mcp = FastMCP("My Server")
_client = None

async def get_client():
    global _client
    if _client is None:
        _client = MyClient()
    return _client

@mcp.on_event("shutdown")  # AttributeError: 'FastMCP' object has no attribute 'on_event'
async def shutdown():
    global _client
    if _client is not None:
        await _client.close()
        _client = None
```

**Error observed:**
```
Failed to run: 'FastMCP' object has no attribute 'on_event'
```

### 1.2 Root Cause

FastMCP does **not** expose event lifecycle hooks like `@app.on_event("startup")` or `@app.on_event("shutdown")` found in FastAPI. The MCP protocol defines a [rigorous lifecycle](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle) (Initialize → Operation → Shutdown), but **FastMCP manages this lifecycle internally** without requiring manual hook registration.

### 1.3 Impact

This antipattern appeared in:
- **HGNC server** (initial implementation, PR #3) - Discovered during server startup testing
- **UniProt server** (initial implementation, Phase 4) - Discovered during server startup testing

Both servers failed to start until the shutdown hooks were removed. This represents a **gap in ADR-002**, which mandates FastMCP scaffolding but does not document lifecycle best practices.

---

## 2. Decision: Module-Level Singleton Pattern

### 2.1 Normative Pattern

All FastMCP servers **MUST** use the **module-level singleton pattern** for managing long-lived resources (HTTP clients, database connections, etc.):

```python
# ✅ CORRECT PATTERN
from fastmcp import FastMCP

mcp = FastMCP("My Server")

# Module-level singleton (shared across tool calls)
_client: MyClient | None = None

async def get_client() -> MyClient:
    """Get or create the shared client.

    FastMCP handles lifecycle internally - no shutdown hook needed.
    """
    global _client
    if _client is None:
        _client = MyClient()
    return _client

@mcp.tool
async def my_tool(query: str):
    """Tool that uses the shared client."""
    client = await get_client()
    return await client.fetch(query)

if __name__ == "__main__":
    mcp.run()  # FastMCP manages startup/shutdown lifecycle
```

### 2.2 Why This Works

1. **Single Process Per Server**: Each `uv run fastmcp run server.py` execution creates one process
2. **Module-Level Scope**: The `_client` variable persists for the process lifetime
3. **Lazy Initialization**: Client is created on first tool invocation (not at import time)
4. **Implicit Cleanup**: When the process terminates (via `mcp.run()` shutdown), all async resources are cleaned up by the Python runtime

### 2.3 FastMCP's Internal Lifecycle Management

From the [FastMCP Quickstart](https://gofastmcp.com/getting-started/quickstart):

> "A FastMCP server is a collection of tools, resources, and other MCP components. To create a server, start by instantiating the `FastMCP` class... That's it!"

FastMCP follows the MCP protocol's [three-phase lifecycle](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle):
1. **Initialization**: Capability negotiation (handled by `mcp.run()`)
2. **Operation**: Tool invocations (your `@mcp.tool` functions)
3. **Shutdown**: Graceful termination (handled by `mcp.run()` exit)

**No manual lifecycle hooks are needed** because FastMCP orchestrates the protocol handshake internally.

---

## 3. Consequences

### 3.1 Positive

- **Simplicity**: No boilerplate lifecycle code required
- **Reliability**: Eliminates runtime errors from non-existent decorators
- **Consistency**: All servers use identical resource management pattern
- **Correctness**: Aligns with FastMCP's design philosophy and MCP protocol

### 3.2 Negative

- **Implicit Cleanup**: Developers may be uncertain about when resources are released (answer: process termination)
- **No Explicit Close**: Cannot add custom cleanup logic (e.g., logging, metrics) at shutdown time
- **Requires Documentation**: Non-obvious to developers familiar with FastAPI's `@app.on_event()` pattern

### 3.3 Mitigation

- **Document in ADR-002 Amendment**: Update Platform Skills documentation to reference ADR-004
- **Add to `/scaffold-fastmcp` skill**: Ensure generated stubs use correct pattern
- **Update CLAUDE.md**: Include lifecycle management in project guidelines

---

## 4. Alternatives Considered

### 4.1 Context Managers (Rejected)

```python
# ❌ Overly complex for module-level singletons
class ClientManager:
    async def __aenter__(self):
        self.client = MyClient()
        return self.client

    async def __aexit__(self, *args):
        await self.client.close()
```

**Rejected because:**
- FastMCP tools are not context managers
- Adds unnecessary complexity for no benefit
- Module-level singleton already provides process-scoped lifecycle

### 4.2 Manual `atexit` Handlers (Rejected)

```python
# ❌ Unnecessary when FastMCP manages lifecycle
import atexit

atexit.register(lambda: asyncio.run(_client.close()))
```

**Rejected because:**
- `atexit` doesn't work reliably with async functions
- Process termination already triggers proper async cleanup
- Adds fragile boilerplate

---

## 5. Implementation

### 5.1 Updates Required

1. **ADR-002 Amendment**: Add section "4.4 Lifecycle Management" referencing ADR-004
2. **`/scaffold-fastmcp` skill**: Update template to use module-level singleton pattern
3. **HGNC server**: Already fixed (shutdown hook removed, PR #3 merged)
4. **UniProt server**: Already fixed (shutdown hook removed, branch `002-uniprot-us3-us4`)

### 5.2 Validation

Both HGNC and UniProt servers now start successfully:

```bash
# HGNC server
$ uv run fastmcp run src/lifesciences_mcp/servers/hgnc.py
# Server starts cleanly, tools accessible

# UniProt server
$ uv run fastmcp run src/lifesciences_mcp/servers/uniprot.py
# Server starts cleanly, tools accessible
```

---

## 6. References

### 6.1 MCP Protocol Specification

- [MCP Lifecycle Specification](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)
  *"The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server connections that ensures proper capability negotiation and state management."*

### 6.2 FastMCP Documentation

- [FastMCP Quickstart](https://gofastmcp.com/getting-started/quickstart)
  *Official documentation showing basic server creation with `mcp = FastMCP("Server Name")`*

### 6.3 Empirical Evidence

- **HGNC Server Lifecycle Bug**: Initial implementation attempted `@mcp.on_event("shutdown")`, failed with `AttributeError`
- **UniProt Server Lifecycle Bug**: Identical error pattern, same fix applied
- **Resolution**: Both servers now use module-level singleton pattern and start successfully

### 6.4 Related ADRs

- **ADR-001 v1.2**: Constitution Principle I (Async-First Architecture) - Defines async client requirements
- **ADR-002 v1.0**: Project Skills (Platform Engineering) - Mandates FastMCP scaffolding but lacked lifecycle guidance
- **ADR-003 v1.0**: SpecKit SDLC - Specification-driven development workflow

---

## 7. Decision Outcome

**Accepted** - All FastMCP servers **MUST** use the module-level singleton pattern for resource management. The `@mcp.on_event()` decorator pattern is explicitly **forbidden** as it does not exist in FastMCP's API.

This decision:
- ✅ Resolves the lifecycle management gap in ADR-002
- ✅ Prevents future runtime errors in new MCP servers
- ✅ Establishes a single, canonical pattern for all servers
- ✅ Aligns with FastMCP's design philosophy

**Effective Date**: 2025-12-22
**Supersedes**: Informal "HGNC lesson" in plan.md line 355 (which incorrectly recommended shutdown hooks)
